'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { supabase } from '@/lib/supabase';
import { useAuth } from '@/lib/auth/AuthProvider';
import { Trophy, Medal, Award, Star, Crown, Target, Zap, TrendingUp, Users } from 'lucide-react';

interface LeaderboardEntry {
  user_id: string;
  username: string;
  full_name?: string;
  best_eq_score: number;
  total_games: number;
  average_eq_score: number;
  current_streak: number;
  total_playtime_seconds: number;
  rank: number;
}

interface LeaderboardProps {
  category?: 'best_score' | 'total_games' | 'average_score' | 'current_streak';
  timeframe?: 'all_time' | 'this_month' | 'this_week';
  limit?: number;
  showUserRank?: boolean;
}

const categoryConfig = {
  'best_score': {
    title: 'Top Scores',
    description: 'Highest individual game scores',
    icon: Trophy,
    color: 'text-yellow-500',
    getValue: (entry: LeaderboardEntry) => `${entry.best_eq_score}%`,
    sortBy: 'best_eq_score'
  },
  'total_games': {
    title: 'Most Active',
    description: 'Total games played',
    icon: Target,
    color: 'text-blue-500',
    getValue: (entry: LeaderboardEntry) => entry.total_games.toString(),
    sortBy: 'total_games'
  },
  'average_score': {
    title: 'Consistent Players',
    description: 'Best average scores',
    icon: Star,
    color: 'text-purple-500',
    getValue: (entry: LeaderboardEntry) => `${entry.average_eq_score}%`,
    sortBy: 'average_eq_score'
  },
  'current_streak': {
    title: 'Streak Masters',
    description: 'Current daily streaks',
    icon: Zap,
    color: 'text-orange-500',
    getValue: (entry: LeaderboardEntry) => `${entry.current_streak} days`,
    sortBy: 'current_streak'
  }
};

const getRankIcon = (rank: number) => {
  switch (rank) {
    case 1:
      return <Crown className="h-5 w-5 text-yellow-500" />;
    case 2:
      return <Medal className="h-5 w-5 text-slate-400" />;
    case 3:
      return <Award className="h-5 w-5 text-orange-600" />;
    default:
      return <span className="text-slate-400 font-bold">#{rank}</span>;
  }
};

export default function Leaderboard({
  category = 'best_score',
  timeframe = 'all_time',
  limit = 10,
  showUserRank = true
}: LeaderboardProps) {
  const { user } = useAuth();
  const [leaderboard, setLeaderboard] = useState<LeaderboardEntry[]>([]);
  const [userRank, setUserRank] = useState<LeaderboardEntry | null>(null);
  const [loading, setLoading] = useState(true);

  const config = categoryConfig[category];

  useEffect(() => {
    fetchLeaderboard();
  }, [category, timeframe]);

  const fetchLeaderboard = async () => {
    try {
      setLoading(true);

      // Base query for public profiles with stats
      let query = supabase
        .from('user_stats')
        .select(`
          user_id,
          best_eq_score,
          total_games,
          average_eq_score,
          current_streak,
          total_playtime_seconds,
          profiles!inner(username, full_name, is_public)
        `)
        .eq('profiles.is_public', true)
        .order(config.sortBy, { ascending: false })
        .limit(limit);

      // Add timeframe filtering if needed
      if (timeframe === 'this_month' || timeframe === 'this_week') {
        const date = new Date();
        if (timeframe === 'this_month') {
          date.setMonth(date.getMonth() - 1);
        } else {
          date.setDate(date.getDate() - 7);
        }
        
        // For timeframe filtering, we'd need to join with game sessions
        // This is a simplified version - in production you'd want to aggregate recent games
        query = query.gte('last_game_date', date.toISOString().split('T')[0]);
      }

      const { data, error } = await query;

      if (error) throw error;

      // Transform data and add rankings
      const leaderboardData: LeaderboardEntry[] = (data || []).map((item, index) => ({
        user_id: item.user_id,
        username: item.profiles.username,
        full_name: item.profiles.full_name,
        best_eq_score: item.best_eq_score || 0,
        total_games: item.total_games || 0,
        average_eq_score: item.average_eq_score || 0,
        current_streak: item.current_streak || 0,
        total_playtime_seconds: item.total_playtime_seconds || 0,
        rank: index + 1
      }));

      setLeaderboard(leaderboardData);

      // Find user's rank if authenticated and requested
      if (user && showUserRank) {
        const userEntry = leaderboardData.find(entry => entry.user_id === user.id);
        if (userEntry) {
          setUserRank(userEntry);
        } else {
          // User not in top results, fetch their specific rank
          const { data: userStats } = await supabase
            .from('user_stats')
            .select(`
              user_id,
              best_eq_score,
              total_games,
              average_eq_score,
              current_streak,
              total_playtime_seconds,
              profiles!inner(username, full_name)
            `)
            .eq('user_id', user.id)
            .single();

          if (userStats) {
            // Calculate user's rank by counting users with better scores
            const { count } = await supabase
              .from('user_stats')
              .select('user_id', { count: 'exact', head: true })
              .gt(config.sortBy, userStats[config.sortBy] || 0)
              .eq('profiles.is_public', true);

            setUserRank({
              user_id: userStats.user_id,
              username: userStats.profiles.username,
              full_name: userStats.profiles.full_name,
              best_eq_score: userStats.best_eq_score || 0,
              total_games: userStats.total_games || 0,
              average_eq_score: userStats.average_eq_score || 0,
              current_streak: userStats.current_streak || 0,
              total_playtime_seconds: userStats.total_playtime_seconds || 0,
              rank: (count || 0) + 1
            });
          }
        }
      }

      setLoading(false);
    } catch (error) {
      console.error('Error fetching leaderboard:', error);
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <Card className="bg-slate-800 border-slate-700">
        <CardContent className="flex items-center justify-center py-8">
          <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="bg-slate-800 border-slate-700">
      <CardHeader>
        <div className="flex items-center gap-3">
          <config.icon className={`h-6 w-6 ${config.color}`} />
          <div>
            <CardTitle className="text-white">{config.title}</CardTitle>
            <CardDescription>{config.description}</CardDescription>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        {leaderboard.length === 0 ? (
          <div className="text-center py-8">
            <Users className="h-12 w-12 text-slate-400 mx-auto mb-4" />
            <h3 className="text-lg font-semibold text-white mb-2">No data yet</h3>
            <p className="text-slate-400">
              Be the first to appear on the leaderboard!
            </p>
          </div>
        ) : (
          <div className="space-y-3">
            {leaderboard.map((entry) => (
              <div 
                key={entry.user_id}
                className={`flex items-center justify-between p-3 rounded-lg transition-colors ${
                  entry.user_id === user?.id 
                    ? 'bg-primary/10 border border-primary/20' 
                    : 'bg-slate-900/50 hover:bg-slate-900/70'
                }`}
              >
                <div className="flex items-center gap-3">
                  <div className="flex items-center justify-center w-8 h-8">
                    {getRankIcon(entry.rank)}
                  </div>
                  <div>
                    <Link 
                      href={`/profile/${entry.username}`}
                      className="font-medium text-white hover:text-primary transition-colors"
                    >
                      {entry.full_name || entry.username}
                    </Link>
                    <p className="text-sm text-slate-400">@{entry.username}</p>
                  </div>
                </div>
                
                <div className="text-right">
                  <p className={`text-lg font-bold ${config.color}`}>
                    {config.getValue(entry)}
                  </p>
                  <p className="text-xs text-slate-400">
                    {entry.total_games} games
                  </p>
                </div>
              </div>
            ))}
            
            {/* User's rank if not in top results */}
            {userRank && userRank.rank > limit && (
              <>
                <div className="border-t border-slate-700 my-4"></div>
                <div className="flex items-center justify-between p-3 rounded-lg bg-primary/10 border border-primary/20">
                  <div className="flex items-center gap-3">
                    <div className="flex items-center justify-center w-8 h-8">
                      <span className="text-primary font-bold">#{userRank.rank}</span>
                    </div>
                    <div>
                      <p className="font-medium text-white">You</p>
                      <p className="text-sm text-slate-400">@{userRank.username}</p>
                    </div>
                  </div>
                  
                  <div className="text-right">
                    <p className={`text-lg font-bold ${config.color}`}>
                      {config.getValue(userRank)}
                    </p>
                    <p className="text-xs text-slate-400">
                      {userRank.total_games} games
                    </p>
                  </div>
                </div>
              </>
            )}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
